## API Report File for "@backstage-community/plugin-mcp-chat-backend"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { BackendFeature } from '@backstage/backend-plugin-api';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import express from 'express';
import { GenerateContentResult } from '@google/generative-ai';
import { LoggerService } from '@backstage/backend-plugin-api';
import { RootConfigService } from '@backstage/backend-plugin-api';

// @public
export interface ChatMessage {
  content: string | null;
  role: 'system' | 'user' | 'assistant' | 'tool';
  tool_call_id?: string;
  tool_calls?: ToolCall[];
}

// @public
export interface ChatResponse {
  choices: [
    {
      message: {
        role: 'assistant';
        content: string | null;
        tool_calls?: ToolCall[];
      };
    },
  ];
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

// @public
export class ClaudeProvider extends LLMProvider {
  // (undocumented)
  protected formatRequest(messages: ChatMessage[], tools?: Tool[]): any;
  // (undocumented)
  protected getHeaders(): Record<string, string>;
  // (undocumented)
  protected parseResponse(response: any): ChatResponse;
  // (undocumented)
  sendMessage(messages: ChatMessage[], tools?: Tool[]): Promise<ChatResponse>;
  // (undocumented)
  testConnection(): Promise<{
    connected: boolean;
    models?: string[];
    error?: string;
  }>;
}

// @public
export function createRouter({
  logger,
  mcpClientService,
}: {
  logger: LoggerService;
  mcpClientService: MCPClientService;
}): Promise<express.Router>;

// @public
export function executeToolCall(
  toolCall: ToolCall,
  tools: ServerTool[],
  mcpClients: Map<string, Client>,
): Promise<ToolExecutionResult>;

// @public
export function findNpxPath(): Promise<string>;

// @public
export class GeminiProvider extends LLMProvider {
  constructor(config: ProviderConfig);
  // (undocumented)
  protected formatRequest(_messages: ChatMessage[], _tools?: Tool[]): any;
  // (undocumented)
  protected getHeaders(): Record<string, string>;
  // (undocumented)
  protected parseResponse(result: GenerateContentResult): ChatResponse;
  // (undocumented)
  sendMessage(messages: ChatMessage[], tools?: Tool[]): Promise<ChatResponse>;
  // (undocumented)
  testConnection(): Promise<{
    connected: boolean;
    models?: string[];
    error?: string;
  }>;
}

// @public
export function getProviderConfig(config: RootConfigService): ProviderConfig;

// @public
export function getProviderInfo(config: RootConfigService): {
  provider: string;
  model: string;
  baseURL: string;
};

// @public
export class LiteLLMProvider extends LLMProvider {
  // (undocumented)
  protected formatRequest(messages: ChatMessage[], tools?: Tool[]): any;
  // (undocumented)
  protected getHeaders(): Record<string, string>;
  // (undocumented)
  protected parseResponse(response: any): ChatResponse;
  // (undocumented)
  sendMessage(messages: ChatMessage[], tools?: Tool[]): Promise<ChatResponse>;
  // (undocumented)
  testConnection(): Promise<{
    connected: boolean;
    models?: string[];
    error?: string;
  }>;
}

// @public
export abstract class LLMProvider {
  constructor(config: ProviderConfig);
  // (undocumented)
  protected apiKey?: string;
  // (undocumented)
  protected baseUrl: string;
  // (undocumented)
  protected abstract formatRequest(
    messages: ChatMessage[],
    tools?: Tool[],
  ): any;
  // (undocumented)
  protected abstract getHeaders(): Record<string, string>;
  // (undocumented)
  protected makeRequest(endpoint: string, body: any): Promise<any>;
  // (undocumented)
  protected model: string;
  // (undocumented)
  protected abstract parseResponse(response: any): ChatResponse;
  // (undocumented)
  abstract sendMessage(
    messages: ChatMessage[],
    tools?: Tool[],
  ): Promise<ChatResponse>;
  // (undocumented)
  abstract testConnection(): Promise<{
    connected: boolean;
    models?: string[];
    error?: string;
  }>;
  // (undocumented)
  protected type: string;
}

// @public
export type LLMProviderType =
  | 'openai'
  | 'openai-responses'
  | 'claude'
  | 'gemini'
  | 'ollama'
  | 'litellm';

// @public
export function loadServerConfigs(
  config: RootConfigService,
): MCPServerFullConfig[];

// @public
const mcpChatPlugin: BackendFeature;
export default mcpChatPlugin;

// @public
export interface MCPClientService {
  getAvailableTools(): ServerTool[];
  getMCPServerStatus(): Promise<MCPServerStatusData>;
  getProviderStatus(): Promise<ProviderStatusData>;
  initializeMCPServers(): Promise<MCPServer[]>;
  processQuery(
    messagesInput: ChatMessage[],
    enabledTools?: string[],
  ): Promise<QueryResponse>;
}

// @public
export class MCPClientServiceImpl implements MCPClientService {
  constructor(options: MCPClientServiceOptions);
  // (undocumented)
  getAvailableTools(): ServerTool[];
  // (undocumented)
  getMCPServerStatus(): Promise<MCPServerStatusData>;
  // (undocumented)
  getProviderStatus(): Promise<ProviderStatusData>;
  // (undocumented)
  initializeMCPServers(): Promise<MCPServer[]>;
  // (undocumented)
  processQuery(
    messagesInput: any[],
    enabledTools?: string[],
  ): Promise<QueryResponse>;
}

// @public
export type MCPClientServiceOptions = {
  logger: LoggerService;
  config: RootConfigService;
};

// @public
export type MCPServer = MCPServerConfig & {
  status: {
    valid: boolean;
    connected: boolean;
    error?: string;
  };
};

// @public
export interface MCPServerConfig {
  args?: string[];
  id: string;
  name: string;
  npxCommand?: string;
  scriptPath?: string;
  type: MCPServerType;
  url?: string;
}

// @public
export type MCPServerFullConfig = MCPServerConfig & MCPServerSecrets;

// @public
export interface MCPServerSecrets {
  env?: Record<string, string>;
  headers?: Record<string, string>;
}

// @public
export interface MCPServerStatusData {
  active: number;
  servers: MCPServer[];
  timestamp: string;
  total: number;
  valid: number;
}

// @public
export enum MCPServerType {
  // (undocumented)
  STDIO = 'stdio',
  // (undocumented)
  STREAMABLE_HTTP = 'streamable-http',
}

// @public
export interface MessageValidationResult {
  error?: string;
  isValid: boolean;
}

// @public
export class OllamaProvider extends LLMProvider {
  constructor(config: any);
  // (undocumented)
  protected formatRequest(messages: ChatMessage[], tools?: Tool[]): any;
  // (undocumented)
  protected getHeaders(): Record<string, string>;
  // (undocumented)
  protected parseResponse(response: any): ChatResponse;
  // (undocumented)
  sendMessage(messages: ChatMessage[], tools?: Tool[]): Promise<ChatResponse>;
  // (undocumented)
  testConnection(): Promise<{
    connected: boolean;
    models?: string[];
    error?: string;
  }>;
}

// @public
export class OpenAIProvider extends LLMProvider {
  // (undocumented)
  protected formatRequest(messages: ChatMessage[], tools?: Tool[]): any;
  // (undocumented)
  protected getHeaders(): Record<string, string>;
  // (undocumented)
  protected parseResponse(response: any): ChatResponse;
  // (undocumented)
  sendMessage(messages: ChatMessage[], tools?: Tool[]): Promise<ChatResponse>;
  // (undocumented)
  testConnection(): Promise<{
    connected: boolean;
    models?: string[];
    error?: string;
  }>;
}

// @public
export class OpenAIResponsesProvider extends LLMProvider {
  // (undocumented)
  protected formatRequest(messages: ChatMessage[], _tools?: Tool[]): any;
  // (undocumented)
  protected getHeaders(): Record<string, string>;
  getLastResponseOutput(): ResponsesApiResponse['output'] | null;
  // (undocumented)
  protected makeRequest(endpoint: string, body: any): Promise<any>;
  // (undocumented)
  protected parseResponse(response: ResponsesApiResponse): ChatResponse;
  // (undocumented)
  sendMessage(messages: ChatMessage[], _tools?: Tool[]): Promise<ChatResponse>;
  setMcpServerConfigs(configs: MCPServerFullConfig[]): void;
  // (undocumented)
  testConnection(): Promise<{
    connected: boolean;
    models?: string[];
    error?: string;
  }>;
}

// @public
export interface ProviderConfig {
  apiKey?: string;
  baseUrl: string;
  model: string;
  type: string;
}

// @public
export interface ProviderConnectionStatus {
  connected: boolean;
  error?: string;
  models?: string[];
}

// @public
export class ProviderFactory {
  static createProvider(config: ProviderConfig): LLMProvider;
}

// @public
export interface ProviderInfo {
  baseUrl: string;
  connection: ProviderConnectionStatus;
  id: string;
  model: string;
}

// @public
export interface ProviderStatusData {
  providers: ProviderInfo[];
  summary: {
    totalProviders: number;
    healthyProviders: number;
    error?: string;
  };
  timestamp: string;
}

// @public
export interface QueryResponse {
  reply: string;
  toolCalls: ToolCall[];
  toolResponses: ToolExecutionResult[];
}

// @public
export interface ResponsesApiMcpCall {
  arguments: string;
  error: string | null;
  id: string;
  name: string;
  output: string;
  server_label: string;
  type: 'mcp_call';
}

// @public
export interface ResponsesApiMcpListTools {
  id: string;
  server_label: string;
  tools: Array<{
    name: string;
    description: string;
    input_schema: Record<string, unknown>;
  }>;
  type: 'mcp_list_tools';
}

// @public
export interface ResponsesApiMcpTool {
  allowed_tools?: string[];
  headers?: Record<string, string>;
  require_approval: 'never' | 'always' | 'auto';
  server_label: string;
  server_url: string;
  type: 'mcp';
}

// @public
export interface ResponsesApiMessage {
  content: Array<{
    type: 'output_text';
    text: string;
    annotations?: unknown[];
  }>;
  id: string;
  role: 'assistant';
  status: 'completed' | 'failed';
  type: 'message';
}

// @public
export type ResponsesApiOutputEvent =
  | ResponsesApiMcpListTools
  | ResponsesApiMcpCall
  | ResponsesApiMessage;

// @public
export interface ResponsesApiResponse {
  created_at: number;
  error?: string | null;
  id: string;
  instructions?: string | null;
  model: string;
  object: 'response';
  output: ResponsesApiOutputEvent[];
  parallel_tool_calls?: boolean;
  previous_response_id?: string | null;
  status: 'completed' | 'failed' | 'cancelled';
  temperature?: number | null;
  text?: {
    format: {
      type: string;
    };
  };
  tools?: ResponsesApiMcpTool[];
  top_p?: number | null;
  truncation?: unknown;
  usage?: {
    input_tokens: number;
    output_tokens: number;
    total_tokens: number;
    input_tokens_details?: {
      cached_tokens: number;
    };
    output_tokens_details?: unknown;
  };
}

// @public
export interface ServerTool extends Tool {
  serverId: string;
}

// @public
export interface Tool {
  function: {
    name: string;
    description: string;
    parameters: Record<string, unknown>;
  };
  type: 'function';
}

// @public
export interface ToolCall {
  function: {
    name: string;
    arguments: string;
  };
  id: string;
  type: 'function';
}

// @public
export interface ToolExecutionResult {
  arguments: Record<string, unknown>;
  id: string;
  name: string;
  result: string;
  serverId: string;
}

// @public
export const VALID_ROLES: readonly ['user', 'assistant', 'system', 'tool'];

// @public
export const validateConfig: (config: RootConfigService) => void;

// @public
export const validateMessages: (messages: unknown) => MessageValidationResult;

// (No @packageDocumentation comment for this package)
```
