/* tslint:disable */
/* eslint-disable */
/**
 * Orchestrator plugin
 * API to interact with orchestrator plugin
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AssessedProcessInstanceDTO
 */
export interface AssessedProcessInstanceDTO {
    /**
     * 
     * @type {ProcessInstanceDTO}
     * @memberof AssessedProcessInstanceDTO
     */
    'instance': ProcessInstanceDTO;
    /**
     * 
     * @type {ProcessInstanceDTO}
     * @memberof AssessedProcessInstanceDTO
     */
    'assessedBy'?: ProcessInstanceDTO;
}
/**
 * The ErrorResponse object represents a common structure for handling errors in API responses. It includes essential information about the error, such as the error message and additional optional details.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * A string providing a concise and human-readable description of the encountered error. This field is required in the ErrorResponse object.
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * An optional field that can contain additional information or context about the error. It provides flexibility for including extra details based on specific error scenarios.
     * @type {string}
     * @memberof ErrorResponse
     */
    'additionalInfo'?: string;
}
/**
 * 
 * @export
 * @interface ExecuteWorkflowRequestDTO
 */
export interface ExecuteWorkflowRequestDTO {
    /**
     * 
     * @type {object}
     * @memberof ExecuteWorkflowRequestDTO
     */
    'inputData': object;
}
/**
 * 
 * @export
 * @interface ExecuteWorkflowResponseDTO
 */
export interface ExecuteWorkflowResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof ExecuteWorkflowResponseDTO
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface FilterInfo
 */
export interface FilterInfo {
    /**
     * The name of the field to filter on
     * @type {string}
     * @memberof FilterInfo
     */
    'fieldName': string;
    /**
     * 
     * @type {Operator}
     * @memberof FilterInfo
     */
    'operator': Operator;
    /**
     * 
     * @type {FilterValue}
     * @memberof FilterInfo
     */
    'fieldValue': FilterValue;
}


/**
 * @type FilterValue
 * The value to filter by, which can be a string, number, boolean, or ProcessInstanceStatusDTO
 * @export
 */
export type FilterValue = boolean | number | string;

/**
 * 
 * @export
 * @interface GetInstancesRequestParams
 */
export interface GetInstancesRequestParams {
    /**
     * 
     * @type {PaginationInfoDTO}
     * @memberof GetInstancesRequestParams
     */
    'paginationInfo'?: PaginationInfoDTO;
    /**
     * 
     * @type {FilterInfo}
     * @memberof GetInstancesRequestParams
     */
    'filterInfo'?: FilterInfo;
}
/**
 * 
 * @export
 * @interface GetOverviewsRequestParams
 */
export interface GetOverviewsRequestParams {
    /**
     * 
     * @type {PaginationInfoDTO}
     * @memberof GetOverviewsRequestParams
     */
    'paginationInfo'?: PaginationInfoDTO;
    /**
     * 
     * @type {FilterInfo}
     * @memberof GetOverviewsRequestParams
     */
    'filterInfo'?: FilterInfo;
}
/**
 * 
 * @export
 * @interface NodeInstanceDTO
 */
export interface NodeInstanceDTO {
    /**
     * Type name
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    '__typename'?: string;
    /**
     * Node instance ID
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    'id': string;
    /**
     * Node name
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    'name'?: string;
    /**
     * Node type
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    'type'?: string;
    /**
     * Date when the node was entered
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    'enter'?: string;
    /**
     * Date when the node was exited (optional)
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    'exit'?: string;
    /**
     * Definition ID
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    'definitionId'?: string;
    /**
     * Node ID
     * @type {string}
     * @memberof NodeInstanceDTO
     */
    'nodeId'?: string;
}
/**
 * The operator to use for filtering, such as equality or inclusion
 * @export
 * @enum {string}
 */

export const Operator = {
    Equal: 'equal',
    In: 'in'
} as const;

export type Operator = typeof Operator[keyof typeof Operator];


/**
 * 
 * @export
 * @interface PaginationInfoDTO
 */
export interface PaginationInfoDTO {
    /**
     * 
     * @type {number}
     * @memberof PaginationInfoDTO
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationInfoDTO
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationInfoDTO
     */
    'totalCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginationInfoDTO
     */
    'orderDirection'?: PaginationInfoDTOOrderDirectionEnum;
    /**
     * 
     * @type {string}
     * @memberof PaginationInfoDTO
     */
    'orderBy'?: string;
}

export const PaginationInfoDTOOrderDirectionEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type PaginationInfoDTOOrderDirectionEnum = typeof PaginationInfoDTOOrderDirectionEnum[keyof typeof PaginationInfoDTOOrderDirectionEnum];

/**
 * 
 * @export
 * @interface ProcessInstanceDTO
 */
export interface ProcessInstanceDTO {
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'processId': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'processName'?: string;
    /**
     * 
     * @type {ProcessInstanceStatusDTO}
     * @memberof ProcessInstanceDTO
     */
    'status'?: ProcessInstanceStatusDTO;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'endpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'serviceUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'start'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'end'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'duration'?: string;
    /**
     * 
     * @type {WorkflowCategoryDTO}
     * @memberof ProcessInstanceDTO
     */
    'category'?: WorkflowCategoryDTO;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'description'?: string;
    /**
     * 
     * @type {WorkflowDataDTO}
     * @memberof ProcessInstanceDTO
     */
    'workflowdata'?: WorkflowDataDTO;
    /**
     * 
     * @type {string}
     * @memberof ProcessInstanceDTO
     */
    'businessKey'?: string;
    /**
     * 
     * @type {Array<NodeInstanceDTO>}
     * @memberof ProcessInstanceDTO
     */
    'nodes': Array<NodeInstanceDTO>;
    /**
     * 
     * @type {ProcessInstanceErrorDTO}
     * @memberof ProcessInstanceDTO
     */
    'error'?: ProcessInstanceErrorDTO;
    /**
     * 
     * @type {object}
     * @memberof ProcessInstanceDTO
     */
    'variables'?: object;
}


/**
 * 
 * @export
 * @interface ProcessInstanceErrorDTO
 */
export interface ProcessInstanceErrorDTO {
    /**
     * Type name
     * @type {string}
     * @memberof ProcessInstanceErrorDTO
     */
    '__typename'?: string;
    /**
     * Node definition ID
     * @type {string}
     * @memberof ProcessInstanceErrorDTO
     */
    'nodeDefinitionId': string;
    /**
     * Error message (optional)
     * @type {string}
     * @memberof ProcessInstanceErrorDTO
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ProcessInstanceListResultDTO
 */
export interface ProcessInstanceListResultDTO {
    /**
     * 
     * @type {Array<ProcessInstanceDTO>}
     * @memberof ProcessInstanceListResultDTO
     */
    'items'?: Array<ProcessInstanceDTO>;
    /**
     * 
     * @type {PaginationInfoDTO}
     * @memberof ProcessInstanceListResultDTO
     */
    'paginationInfo'?: PaginationInfoDTO;
}
/**
 * Status of the workflow run
 * @export
 * @enum {string}
 */

export const ProcessInstanceStatusDTO = {
    Active: 'Active',
    Error: 'Error',
    Completed: 'Completed',
    Aborted: 'Aborted',
    Suspended: 'Suspended',
    Pending: 'Pending'
} as const;

export type ProcessInstanceStatusDTO = typeof ProcessInstanceStatusDTO[keyof typeof ProcessInstanceStatusDTO];


/**
 * Category of the workflow
 * @export
 * @enum {string}
 */

export const WorkflowCategoryDTO = {
    Assessment: 'assessment',
    Infrastructure: 'infrastructure'
} as const;

export type WorkflowCategoryDTO = typeof WorkflowCategoryDTO[keyof typeof WorkflowCategoryDTO];


/**
 * 
 * @export
 * @interface WorkflowDTO
 */
export interface WorkflowDTO {
    /**
     * Workflow unique identifier
     * @type {string}
     * @memberof WorkflowDTO
     */
    'id': string;
    /**
     * Workflow name
     * @type {string}
     * @memberof WorkflowDTO
     */
    'name'?: string;
    /**
     * 
     * @type {WorkflowFormatDTO}
     * @memberof WorkflowDTO
     */
    'format': WorkflowFormatDTO;
    /**
     * 
     * @type {WorkflowCategoryDTO}
     * @memberof WorkflowDTO
     */
    'category': WorkflowCategoryDTO;
    /**
     * Description of the workflow
     * @type {string}
     * @memberof WorkflowDTO
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkflowDTO
     */
    'annotations'?: Array<string>;
}


/**
 * 
 * @export
 * @interface WorkflowDataDTO
 */
export interface WorkflowDataDTO {
    /**
     * 
     * @type {Array<Array<WorkflowSuggestionDTO>>}
     * @memberof WorkflowDataDTO
     */
    'workflowoptions'?: Array<Array<WorkflowSuggestionDTO>>;
}
/**
 * Format of the workflow definition
 * @export
 * @enum {string}
 */

export const WorkflowFormatDTO = {
    Yaml: 'yaml',
    Json: 'json'
} as const;

export type WorkflowFormatDTO = typeof WorkflowFormatDTO[keyof typeof WorkflowFormatDTO];


/**
 * 
 * @export
 * @interface WorkflowListResultDTO
 */
export interface WorkflowListResultDTO {
    /**
     * 
     * @type {Array<WorkflowDTO>}
     * @memberof WorkflowListResultDTO
     */
    'items': Array<WorkflowDTO>;
    /**
     * 
     * @type {PaginationInfoDTO}
     * @memberof WorkflowListResultDTO
     */
    'paginationInfo': PaginationInfoDTO;
}
/**
 * 
 * @export
 * @interface WorkflowOverviewDTO
 */
export interface WorkflowOverviewDTO {
    /**
     * Workflow unique identifier
     * @type {string}
     * @memberof WorkflowOverviewDTO
     */
    'workflowId': string;
    /**
     * Workflow name
     * @type {string}
     * @memberof WorkflowOverviewDTO
     */
    'name'?: string;
    /**
     * 
     * @type {WorkflowFormatDTO}
     * @memberof WorkflowOverviewDTO
     */
    'format': WorkflowFormatDTO;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOverviewDTO
     */
    'lastRunId'?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowOverviewDTO
     */
    'lastTriggeredMs'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOverviewDTO
     */
    'lastRunStatus'?: string;
    /**
     * 
     * @type {WorkflowCategoryDTO}
     * @memberof WorkflowOverviewDTO
     */
    'category'?: WorkflowCategoryDTO;
    /**
     * 
     * @type {number}
     * @memberof WorkflowOverviewDTO
     */
    'avgDurationMs'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowOverviewDTO
     */
    'description'?: string;
}


/**
 * 
 * @export
 * @interface WorkflowOverviewListResultDTO
 */
export interface WorkflowOverviewListResultDTO {
    /**
     * 
     * @type {Array<WorkflowOverviewDTO>}
     * @memberof WorkflowOverviewListResultDTO
     */
    'overviews'?: Array<WorkflowOverviewDTO>;
    /**
     * 
     * @type {PaginationInfoDTO}
     * @memberof WorkflowOverviewListResultDTO
     */
    'paginationInfo'?: PaginationInfoDTO;
}
/**
 * 
 * @export
 * @interface WorkflowProgressDTO
 */
export interface WorkflowProgressDTO {
    /**
     * Type name
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    '__typename'?: any;
    /**
     * Node instance ID
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    'id': any;
    /**
     * Node name
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    'name'?: any;
    /**
     * Node type
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    'type'?: any;
    /**
     * Date when the node was entered
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    'enter'?: any;
    /**
     * Date when the node was exited (optional)
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    'exit'?: any;
    /**
     * Definition ID
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    'definitionId'?: any;
    /**
     * Node ID
     * @type {any}
     * @memberof WorkflowProgressDTO
     */
    'nodeId'?: any;
    /**
     * 
     * @type {ProcessInstanceStatusDTO}
     * @memberof WorkflowProgressDTO
     */
    'status'?: ProcessInstanceStatusDTO;
    /**
     * 
     * @type {ProcessInstanceErrorDTO}
     * @memberof WorkflowProgressDTO
     */
    'error'?: ProcessInstanceErrorDTO;
}


/**
 * 
 * @export
 * @interface WorkflowRunStatusDTO
 */
export interface WorkflowRunStatusDTO {
    /**
     * 
     * @type {string}
     * @memberof WorkflowRunStatusDTO
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowRunStatusDTO
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface WorkflowSuggestionDTO
 */
export interface WorkflowSuggestionDTO {
    /**
     * 
     * @type {string}
     * @memberof WorkflowSuggestionDTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowSuggestionDTO
     */
    'name'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Aborts a workflow instance identified by the provided instanceId.
         * @summary Abort a workflow instance
         * @param {string} instanceId The identifier of the workflow instance to abort.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortWorkflow: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('abortWorkflow', 'instanceId', instanceId)
            const localVarPath = `/v2/instances/{instanceId}/abort`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute a workflow
         * @param {string} workflowId ID of the workflow to execute
         * @param {ExecuteWorkflowRequestDTO} executeWorkflowRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflow: async (workflowId: string, executeWorkflowRequestDTO: ExecuteWorkflowRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('executeWorkflow', 'workflowId', workflowId)
            // verify required parameter 'executeWorkflowRequestDTO' is not null or undefined
            assertParamExists('executeWorkflow', 'executeWorkflowRequestDTO', executeWorkflowRequestDTO)
            const localVarPath = `/v2/workflows/{workflowId}/execute`
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeWorkflowRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Workflow Instance by ID
         * @param {string} instanceId ID of the workflow instance
         * @param {boolean} [includeAssessment] Whether to include assessment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceById: async (instanceId: string, includeAssessment?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('getInstanceById', 'instanceId', instanceId)
            const localVarPath = `/v2/workflows/instances/{instanceId}`
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeAssessment !== undefined) {
                localVarQueryParameter['includeAssessment'] = includeAssessment;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of instances
         * @summary Get instances
         * @param {GetInstancesRequestParams} [getInstancesRequestParams] Parameters for retrieving instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstances: async (getInstancesRequestParams?: GetInstancesRequestParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/workflows/instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getInstancesRequestParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a workflow by ID
         * @param {string} workflowId ID of the workflow to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowById: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflowById', 'workflowId', workflowId)
            const localVarPath = `/v2/workflows/{workflowId}`
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a workflow overview by ID
         * @param {string} workflowId Unique identifier of the workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowOverviewById: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflowOverviewById', 'workflowId', workflowId)
            const localVarPath = `/v2/workflows/{workflowId}/overview`
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a workflow source by ID
         * @param {string} workflowId ID of the workflow to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowSourceById: async (workflowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('getWorkflowSourceById', 'workflowId', workflowId)
            const localVarPath = `/v2/workflows/{workflowId}/source`
                .replace(`{${"workflowId"}}`, encodeURIComponent(String(workflowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of workflow statuses
         * @summary Get workflow status list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatuses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/workflows/instances/statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of workflow overviews
         * @param {GetOverviewsRequestParams} [getOverviewsRequestParams] Parameters for retrieving of workflow overviews
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowsOverview: async (getOverviewsRequestParams?: GetOverviewsRequestParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/workflows/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getOverviewsRequestParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Aborts a workflow instance identified by the provided instanceId.
         * @summary Abort a workflow instance
         * @param {string} instanceId The identifier of the workflow instance to abort.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async abortWorkflow(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.abortWorkflow(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.abortWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Execute a workflow
         * @param {string} workflowId ID of the workflow to execute
         * @param {ExecuteWorkflowRequestDTO} executeWorkflowRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeWorkflow(workflowId: string, executeWorkflowRequestDTO: ExecuteWorkflowRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteWorkflowResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeWorkflow(workflowId, executeWorkflowRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.executeWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Workflow Instance by ID
         * @param {string} instanceId ID of the workflow instance
         * @param {boolean} [includeAssessment] Whether to include assessment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstanceById(instanceId: string, includeAssessment?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssessedProcessInstanceDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstanceById(instanceId, includeAssessment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getInstanceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of instances
         * @summary Get instances
         * @param {GetInstancesRequestParams} [getInstancesRequestParams] Parameters for retrieving instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstances(getInstancesRequestParams?: GetInstancesRequestParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessInstanceListResultDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstances(getInstancesRequestParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getInstances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a workflow by ID
         * @param {string} workflowId ID of the workflow to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowById(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowById(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWorkflowById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a workflow overview by ID
         * @param {string} workflowId Unique identifier of the workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowOverviewById(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOverviewDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowOverviewById(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWorkflowOverviewById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a workflow source by ID
         * @param {string} workflowId ID of the workflow to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowSourceById(workflowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowSourceById(workflowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWorkflowSourceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of workflow statuses
         * @summary Get workflow status list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowStatuses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowRunStatusDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowStatuses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWorkflowStatuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of workflow overviews
         * @param {GetOverviewsRequestParams} [getOverviewsRequestParams] Parameters for retrieving of workflow overviews
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflowsOverview(getOverviewsRequestParams?: GetOverviewsRequestParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowOverviewListResultDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflowsOverview(getOverviewsRequestParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWorkflowsOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Aborts a workflow instance identified by the provided instanceId.
         * @summary Abort a workflow instance
         * @param {string} instanceId The identifier of the workflow instance to abort.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortWorkflow(instanceId: string, options?: any): AxiosPromise<string> {
            return localVarFp.abortWorkflow(instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute a workflow
         * @param {string} workflowId ID of the workflow to execute
         * @param {ExecuteWorkflowRequestDTO} executeWorkflowRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWorkflow(workflowId: string, executeWorkflowRequestDTO: ExecuteWorkflowRequestDTO, options?: any): AxiosPromise<ExecuteWorkflowResponseDTO> {
            return localVarFp.executeWorkflow(workflowId, executeWorkflowRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Workflow Instance by ID
         * @param {string} instanceId ID of the workflow instance
         * @param {boolean} [includeAssessment] Whether to include assessment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceById(instanceId: string, includeAssessment?: boolean, options?: any): AxiosPromise<AssessedProcessInstanceDTO> {
            return localVarFp.getInstanceById(instanceId, includeAssessment, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of instances
         * @summary Get instances
         * @param {GetInstancesRequestParams} [getInstancesRequestParams] Parameters for retrieving instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstances(getInstancesRequestParams?: GetInstancesRequestParams, options?: any): AxiosPromise<ProcessInstanceListResultDTO> {
            return localVarFp.getInstances(getInstancesRequestParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a workflow by ID
         * @param {string} workflowId ID of the workflow to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowById(workflowId: string, options?: any): AxiosPromise<WorkflowDTO> {
            return localVarFp.getWorkflowById(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a workflow overview by ID
         * @param {string} workflowId Unique identifier of the workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowOverviewById(workflowId: string, options?: any): AxiosPromise<WorkflowOverviewDTO> {
            return localVarFp.getWorkflowOverviewById(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a workflow source by ID
         * @param {string} workflowId ID of the workflow to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowSourceById(workflowId: string, options?: any): AxiosPromise<string> {
            return localVarFp.getWorkflowSourceById(workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of workflow statuses
         * @summary Get workflow status list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowStatuses(options?: any): AxiosPromise<Array<WorkflowRunStatusDTO>> {
            return localVarFp.getWorkflowStatuses(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of workflow overviews
         * @param {GetOverviewsRequestParams} [getOverviewsRequestParams] Parameters for retrieving of workflow overviews
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflowsOverview(getOverviewsRequestParams?: GetOverviewsRequestParams, options?: any): AxiosPromise<WorkflowOverviewListResultDTO> {
            return localVarFp.getWorkflowsOverview(getOverviewsRequestParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Aborts a workflow instance identified by the provided instanceId.
     * @summary Abort a workflow instance
     * @param {string} instanceId The identifier of the workflow instance to abort.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public abortWorkflow(instanceId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).abortWorkflow(instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute a workflow
     * @param {string} workflowId ID of the workflow to execute
     * @param {ExecuteWorkflowRequestDTO} executeWorkflowRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public executeWorkflow(workflowId: string, executeWorkflowRequestDTO: ExecuteWorkflowRequestDTO, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).executeWorkflow(workflowId, executeWorkflowRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Workflow Instance by ID
     * @param {string} instanceId ID of the workflow instance
     * @param {boolean} [includeAssessment] Whether to include assessment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getInstanceById(instanceId: string, includeAssessment?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getInstanceById(instanceId, includeAssessment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of instances
     * @summary Get instances
     * @param {GetInstancesRequestParams} [getInstancesRequestParams] Parameters for retrieving instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getInstances(getInstancesRequestParams?: GetInstancesRequestParams, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getInstances(getInstancesRequestParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a workflow by ID
     * @param {string} workflowId ID of the workflow to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWorkflowById(workflowId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWorkflowById(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a workflow overview by ID
     * @param {string} workflowId Unique identifier of the workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWorkflowOverviewById(workflowId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWorkflowOverviewById(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a workflow source by ID
     * @param {string} workflowId ID of the workflow to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWorkflowSourceById(workflowId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWorkflowSourceById(workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of workflow statuses
     * @summary Get workflow status list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWorkflowStatuses(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWorkflowStatuses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of workflow overviews
     * @param {GetOverviewsRequestParams} [getOverviewsRequestParams] Parameters for retrieving of workflow overviews
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWorkflowsOverview(getOverviewsRequestParams?: GetOverviewsRequestParams, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWorkflowsOverview(getOverviewsRequestParams, options).then((request) => request(this.axios, this.basePath));
    }
}



