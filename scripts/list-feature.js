#!/usr/bin/env node
/*
 * Copyright 2026 The Backstage Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import fs from 'fs-extra';
import { getPackages } from '@manypkg/get-packages';
import { resolve, join } from 'path';
import arrayToTable from 'array-to-table';
import * as url from 'url';
import { listWorkspaces } from './list-workspaces.js';

const __dirname = url.fileURLToPath(new URL('.', import.meta.url));
const DEFAULT_BRANCH = 'master';
const REPORT_PATH = 'report.api.md';
const REPORT_PATH_ALPHA = 'report-alpha.api.md';
const ROLE_MAP = {
  frontend: {
    check: report =>
      report
        .split('\n')
        .some(
          line =>
            line.includes(`from '@backstage/frontend-plugin-api'`) &&
            (line.includes('FrontendModule') ||
              line.includes('FrontendPlugin')),
        ),
    reportPath: resolve(
      __dirname,
      '..',
      'docs',
      'compatibility',
      'new-frontend-system.md',
    ),
    roles: ['frontend-plugin', 'frontend-plugin-module'],
  },
};

const safeReadFile = async filePath => {
  try {
    return (await fs.readFile(filePath)).toString();
  } catch {
    return '';
  }
};

const processPackage = async (pkg, version, check) => {
  const hasAlphaReport = check(
    await safeReadFile(join(pkg.dir, REPORT_PATH_ALPHA)),
  );
  const hasReport = check(await safeReadFile(join(pkg.dir, REPORT_PATH)));

  // key order here determines order of columns in generated table
  return {
    package: pkg.packageJson.name,
    role: pkg.packageJson.backstage.role,
    ...(hasAlphaReport || hasReport ? { supported: true } : null),
    ['Tested with Backstage version']: version,
    ...(hasAlphaReport || hasReport
      ? { alpha: hasAlphaReport || !hasReport }
      : null),
    readme: `[README](${pkg.packageJson.repository.url}/blob/${DEFAULT_BRANCH}/${pkg.packageJson.repository.directory}/README.md)`,
  };
};

async function main(args) {
  const roleArg = args.indexOf('--role');
  const role = args[roleArg + 1];
  if (roleArg === -1 || !role) {
    console.error(
      `--role param must be specified\n\nValid options are: ${Object.keys(
        ROLE_MAP,
      )}`,
    );
    process.exit(2);
  }
  if (!Object.hasOwn(ROLE_MAP, role)) {
    console.error(
      `Unknown role specified: ${role} - expected one of ${Object.keys(
        ROLE_MAP,
      )}`,
    );
    process.exit(3);
  }

  const config = ROLE_MAP[role];

  const reports = await (
    await listWorkspaces({ fullPath: true })
  ).reduce(async (result, workspace) => {
    const {
      default: { version },
    } = await import(join(workspace, 'backstage.json'), {
      with: { type: 'json' },
    });

    const { packages } = await getPackages(workspace);

    return packages.reduce(async (promise, pkg) => {
      if (config.roles.includes(pkg.packageJson.backstage?.role)) {
        const array = await promise;
        array.push(await processPackage(pkg, version, config.check));

        return array;
      }

      return promise;
    }, result);
  }, []);

  const json = args.includes('--json');
  const save = args.includes('--save');
  const table = args.includes('--table');

  if (table) {
    console.log(arrayToTable(reports));
  } else {
    console.log(json ? JSON.stringify(reports, null, 2) : reports);
  }

  if (save) {
    if (!config.reportPath) {
      console.error(`--save is not supported for this role (${role})`);
      process.exit(4);
    }

    await fs.writeFile(
      config.reportPath,
      (
        await fs.readFile(config.reportPath, 'utf8')
      ).replace(
        /<!-- This table is automatically generated by the list-feature script -->[\s\S]*<!-- end of table -->/,
        `<!-- This table is automatically generated by the list-feature script -->

${arrayToTable(reports)}

<!-- end of table -->`,
      ),
    );
  }
}

if (process.argv[1] === url.fileURLToPath(import.meta.url)) {
  main(process.argv.slice(2)).catch(error => {
    console.error(error.stack || error);
    process.exit(1);
  });
}
